Describe filetype indent
  Before each
    new
    setfiletype python
    setlocal expandtab
    setlocal shiftwidth=4
    only!
  End

  It sets local options
    Assert False(&lisp)
    Assert True(&autoindent)
    Assert Equals(&indentexpr, 'GetPEP8PythonIndent(v:lnum)')

    Assert NotMatch(&indentkeys, '0[[({]')
    Assert NotMatch(&indentkeys, ':\%(>\)\@!')
    Assert Match(&indentkeys, '0)')
    Assert Match(&indentkeys, '0]')
    Assert Match(&indentkeys, '0}')
    Assert Match(&indentkeys, '<:>')
    Assert Match(&indentkeys, '=elif')
    Assert Match(&indentkeys, '=except')
    Assert Match(&indentkeys, '=finally')
  End

  Describe string
    It keeps current indent
      let in = "'\<CR>'"
      let out = [
      \  "'",
      \  "'",
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It keeps current indent (triple-quoted string)
      let in = "'''\<CR>'''"
      let out = [
      \  "'''",
      \  "'''",
      \]
      Assert Equals(Insert(in), Buffer(out))
    End
  End

  Describe line continuation
    It increments indentation level
      let in = "i = 1 + \\\<CR>2 + \\\<CR>3"
      let out = [
      \  'i = 1 + \',
      \  '    2 + \',
      \  '    3',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It indents by option value
      let b:python_indent_continue = '&sw / 2'
      let in = "i = 1 + \\\<CR>2 + \\\<CR>3"
      let out = [
      \  'i = 1 + \',
      \  '  2 + \',
      \  '  3',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End
  End

  Describe list
    It aligns with left bracket
      let in = "l = [0,\<CR># [\<CR>1,\<CR># ]\<CR>2]"
      let out = [
      \  'l = [0,',
      \  '     # [',
      \  '     1,',
      \  '     # ]',
      \  '     2]',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It increments indentation level (hanging indent)
      let in = "l = [\<CR># [\<CR>0,\<CR>1,\<CR>2,\<CR># ]\<CR>]"
      let out = [
      \  'l = [',
      \  '    # [',
      \  '    0,',
      \  '    1,',
      \  '    2,',
      \  '    # ]',
      \  ']',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It indents by option value (hanging indent)
      let b:python_indent_continue = '&sw / 2'
      let in = "l = [\<CR>0,\<CR>1,\<CR>2,\<CR>]"
      let out = [
      \  'l = [',
      \  '  0,',
      \  '  1,',
      \  '  2,',
      \  ']',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It increments indentaion level for right bracket (hanging indent)
      let b:python_indent_right_bracket = 1
      let in = "l = [\<CR>0,\<CR>1,\<CR>2,\<CR>]"
      let out = [
      \  'l = [',
      \  '    0,',
      \  '    1,',
      \  '    2,',
      \  '    ]',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End
  End

  Describe function
    It aligns with left bracket
      let in = "def func(*args,\<CR>**kwargs):"
      let out = [
      \  'def func(*args,',
      \  '         **kwargs):',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It increments indentation level (hanging indent)
      let in = "def func(\<CR>*args,\<CR>**kwargs):"
      let out = [
      \  'def func(',
      \  '        *args,',
      \  '        **kwargs):',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End
  End

  Describe if-statement
    It aligns with left bracket
      let in = "if (True and\<CR>True):"
      let out = [
      \  'if (True and',
      \  '    True):',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It increments indentation level by 2
      let b:python_indent_multiline_statement = 1
      let in = "if (True and\<CR>True):"
      let out = [
      \  'if (True and',
      \  '        True):',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It increments indentaion level (hanging indent)
      let in = "if (\<CR>True and\<CR>True\<CR>):"
      let out = [
      \  'if (',
      \  '    True and',
      \  '    True',
      \  '):',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It increments indentation level by 2 (hanging indent)
      let b:python_indent_multiline_statement = 1
      let in = "if (\<CR>True and\<CR>True\<CR>):"
      let out = [
      \  'if (',
      \  '        True and',
      \  '        True',
      \  '):',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It increments indentation level (line continueation)
      let in = "if True and \\\<CR>True:"
      let out = [
      \  'if True and \',
      \  '    True:',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It increments indentation level by 2 (line continuation)
      let b:python_indent_multiline_statement = 1
      let in = "if True and \\\<CR>True:"
      let out = [
      \  'if True and \',
      \  '        True:',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End
  End

  Describe compound statement
    It indents elif-statement
      let in  = "if 1:\<CR>i = 1\<CR>elif 2:\<CR>"
      let in .= "if 3:\<CR>i = 3\<CR>elif 4:\<CR>i = 4\<CR>elif 5:"
      let out = [
      \  'if 1:',
      \  '    i = 1',
      \  'elif 2:',
      \  '    if 3:',
      \  '        i = 3',
      \  '    elif 4:',
      \  '        i = 4',
      \  '    elif 5:',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It indents else-statement
      let in  = "if 1:\<CR>i = 1\<CR>else:\<CR>"
      let in .= "if 2:\<CR>i = 2\<CR>elif 3:\<CR>pass\<CR>else:\<CR>"
      let in .= "for _ in []:\<CR>continue\<CR>else:\<CR>"
      let in .= "try:\<CR>i = 4\<CR>else:\<CR>"
      let in .= "try:\<CR>i = 5\<CR>except:\<CR>raise\<CR>else:"
      let out = [
      \  'if 1:',
      \  '    i = 1',
      \  'else:',
      \  '    if 2:',
      \  '        i = 2',
      \  '    elif 3:',
      \  '        pass',
      \  '    else:',
      \  '        for _ in []:',
      \  '            continue',
      \  '        else:',
      \  '            try:',
      \  '                i = 4',
      \  '            else:',
      \  '                try:',
      \  '                    i = 5',
      \  '                except:',
      \  '                    raise',
      \  '                else:',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It indents except-statement
      let in = "try:\<CR>i = 1\<CR>except OSError:\<CR>raise\<CR>except:"
      let out = [
      \  'try:',
      \  '    i = 1',
      \  'except OSError:',
      \  '    raise',
      \  'except:',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It indents finally-statement
      let in  = "try:\<CR>i = 1\<CR>finally:\<CR>"
      let in .= "try:\<CR>i = 2\<CR>except:\<CR>raise\<CR>finally:\<CR>"
      let in .= "try:\<CR>i = 3\<CR>else:\<CR>pass\<CR>finally:"
      let out = [
      \  'try:',
      \  '    i = 1',
      \  'finally:',
      \  '    try:',
      \  '        i = 2',
      \  '    except:',
      \  '        raise',
      \  '    finally:',
      \  '        try:',
      \  '            i = 3',
      \  '        else:',
      \  '            pass',
      \  '        finally:',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It ignores compound statement in string
      let in  = "if 1:\<CR>"
      let in .= "if 2:\<CR>s = '''\<CR>"
      let in .= "0\<C-D>if 3:\<CR>\<C-T>pass'''\<CR>elif 4:"
      let out = [
      \  'if 1:',
      \  '    if 2:',
      \  "        s = '''",
      \  'if 3:',
      \  "    pass'''",
      \  '    elif 4:',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End

    It ignores unindented comment
      let in  = "def func():\<CR>"
      let in .= "if 1:\<CR>pass\<CR>"
      let in .= "0\<C-D>  # comment\<CR>"
      let in .= "elif 2:"
      let out = [
      \  'def func():',
      \  '    if 1:',
      \  '        pass',
      \  '  # comment',
      \  '    elif 2:',
      \]
      Assert Equals(Insert(in), Buffer(out))
    End
  End
End
